package com.mentalhealthforum.mentalhealthforum_backend.service.impl;

import com.mentalhealthforum.mentalhealthforum_backend.enums.VerificationType;
import com.mentalhealthforum.mentalhealthforum_backend.exception.error.InvalidTokenException;
import com.mentalhealthforum.mentalhealthforum_backend.exception.error.TokenExpiredException;
import com.mentalhealthforum.mentalhealthforum_backend.exception.error.TooManyRequestsException;
import com.mentalhealthforum.mentalhealthforum_backend.model.VerificationToken;
import com.mentalhealthforum.mentalhealthforum_backend.repository.VerificationTokenRepository;
import com.mentalhealthforum.mentalhealthforum_backend.service.VerificationTokenService;
import org.springframework.stereotype.Service;
import reactor.core.publisher.Mono;

import java.time.Duration;
import java.time.Instant;
import java.util.UUID;

@Service
public class VerificationTokenServiceImpl implements VerificationTokenService {

    private final VerificationTokenRepository tokenRepository;
    private static final Duration TOKEN_EXPIRY = Duration.ofHours(24);

    public VerificationTokenServiceImpl(VerificationTokenRepository tokenRepository) {
        this.tokenRepository = tokenRepository;
    }

    /**
     * Strictly creates the record in the verification_tokens table.
     */
    @Override
    public Mono<VerificationToken> generateToken(String email, VerificationType type, String groupPath, String newValue) {
        // Clean up old tokens for this email to ensure only one is active
        return tokenRepository.deleteByEmailAndType(email, type) // Only kill same-type tokens
                .then(Mono.defer(() -> {
                    VerificationToken newToken = new VerificationToken(
                            null, // ID generated by DB,
                            UUID.randomUUID().toString(),
                            email,
                            Instant.now().plus(TOKEN_EXPIRY),
                            type,
                            groupPath,
                            newValue
                    );
                    return tokenRepository.save(newToken);
        }));
    }

    @Override
    public Mono<Void> checkRateLimit(String email){
        String normalizedEmail = email.trim().toLowerCase();
        return  tokenRepository.findByEmail(normalizedEmail)
                .flatMap(existingToken -> {
                    // If the token was created less than 2 minutes ago, block the request
                    if(existingToken.getCreatedAt().isAfter(Instant.now().minus(Duration.ofMinutes(2)))){
                        return Mono.error(
                                new TooManyRequestsException("Please wait at least 2 minutes before requesting another verification email."));
                    }

                    return Mono.empty();
                });
    }

    @Override
    public Mono<VerificationToken> findByEmail(String email){
        String normalizedEmail = email.trim().toLowerCase();
        return tokenRepository.findByEmail(email)
                .flatMap(verificationToken -> {
                    if(verificationToken.isExpired()){
                        return tokenRepository.delete(verificationToken)
                                .then(Mono.empty());
                    }
                    return Mono.just(verificationToken);
                });
    }


    @Override
    public Mono<VerificationToken> findTokenByEmailAndType(String email, VerificationType type){
        String normalizedEmail = email.trim().toLowerCase();

        return tokenRepository.findByEmailAndType(normalizedEmail, type)
                .flatMap(verificationToken -> {
                    if(verificationToken.isExpired()){
                        // Cleanup expired tokens on the fly
                        return tokenRepository.delete(verificationToken)
                                .then(Mono.empty());
                    }
                    return Mono.just(verificationToken);
                });
    }

    /**
     * Strictly finds and validates the token exists and isn't expired.
     */
    @Override
    public Mono<VerificationToken> findAndValidateToken(String token, String email) {
        return tokenRepository.findByTokenAndEmail(token, email)
                .switchIfEmpty(Mono.error(new InvalidTokenException()))
                .flatMap(foundToken -> {
                    if(foundToken.isExpired()){
                        return tokenRepository.delete(foundToken)
                                .then(Mono.error(new TokenExpiredException()));
                    }
                    return Mono.just(foundToken);
                });
    }

    @Override
    public Mono<Void> removeToken(Long id) {
        return tokenRepository.deleteById(id);
    }

    @Override
    public Mono<Void> removeToken(String email){
        return tokenRepository.deleteByEmail(email);
    }
}
